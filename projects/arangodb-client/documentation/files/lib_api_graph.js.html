<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/api/graph.js - arango</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
        
	    <img alt="arango" src="http://kaerus.com/images/kaerus_logo.png" style="max-height: 65%;" title="arango">
        
            arango
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>1.1.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/action", "classes/admin", "classes/aqlfunction", "classes/batch", "classes/collection", "classes/cursor", "classes/database", "classes/document", "classes/edge", "classes/endpoint", "classes/graph", "classes/import", "classes/index", "classes/jobs", "classes/query", "classes/simple", "classes/transaction", "classes/traversal", "classes/users", "modules/action", "modules/admin", "modules/aqlfunction", "modules/arango", "modules/batch", "modules/collection", "modules/cursor", "modules/database", "modules/document", "modules/edge", "modules/endpoint", "modules/graph", "modules/import", "modules/index", "modules/jobs", "modules/query", "modules/simple", "modules/transaction", "modules/traversal", "modules/users"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
    <h3>APIs</h3>
    <div id="sidebar">
        <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
            <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
            <li><a href="#modules" data-toggle="tab">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" placeholder="Type to filter APIs">
        </div>

        <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
            <div class="tab-pane active" id="classes">
                <ul id="api-classes" class="nav nav-list">
                    
                        <li><a href="../classes/action.html">action</a></li>
                    
                        <li><a href="../classes/admin.html">admin</a></li>
                    
                        <li><a href="../classes/aqlfunction.html">aqlfunction</a></li>
                    
                        <li><a href="../classes/batch.html">batch</a></li>
                    
                        <li><a href="../classes/collection.html">collection</a></li>
                    
                        <li><a href="../classes/cursor.html">cursor</a></li>
                    
                        <li><a href="../classes/database.html">database</a></li>
                    
                        <li><a href="../classes/document.html">document</a></li>
                    
                        <li><a href="../classes/edge.html">edge</a></li>
                    
                        <li><a href="../classes/endpoint.html">endpoint</a></li>
                    
                        <li><a href="../classes/graph.html">graph</a></li>
                    
                        <li><a href="../classes/import.html">import</a></li>
                    
                        <li><a href="../classes/index.html">index</a></li>
                    
                        <li><a href="../classes/jobs.html">jobs</a></li>
                    
                        <li><a href="../classes/query.html">query</a></li>
                    
                        <li><a href="../classes/simple.html">simple</a></li>
                    
                        <li><a href="../classes/transaction.html">transaction</a></li>
                    
                        <li><a href="../classes/traversal.html">traversal</a></li>
                    
                        <li><a href="../classes/users.html">users</a></li>
                    
                </ul>
            </div>

            <div class="tab-pane" id="modules">
                <ul id="api-modules" class="nav nav-list">
                    
                        <li><a href="../modules/action.html">action</a></li>
                    
                        <li><a href="../modules/admin.html">admin</a></li>
                    
                        <li><a href="../modules/aqlfunction.html">aqlfunction</a></li>
                    
                        <li><a href="../modules/arango.html">arango</a></li>
                    
                        <li><a href="../modules/batch.html">batch</a></li>
                    
                        <li><a href="../modules/collection.html">collection</a></li>
                    
                        <li><a href="../modules/cursor.html">cursor</a></li>
                    
                        <li><a href="../modules/database.html">database</a></li>
                    
                        <li><a href="../modules/document.html">document</a></li>
                    
                        <li><a href="../modules/edge.html">edge</a></li>
                    
                        <li><a href="../modules/endpoint.html">endpoint</a></li>
                    
                        <li><a href="../modules/graph.html">graph</a></li>
                    
                        <li><a href="../modules/import.html">import</a></li>
                    
                        <li><a href="../modules/index.html">index</a></li>
                    
                        <li><a href="../modules/jobs.html">jobs</a></li>
                    
                        <li><a href="../modules/query.html">query</a></li>
                    
                        <li><a href="../modules/simple.html">simple</a></li>
                    
                        <li><a href="../modules/transaction.html">transaction</a></li>
                    
                        <li><a href="../modules/traversal.html">traversal</a></li>
                    
                        <li><a href="../modules/users.html">users</a></li>
                    
                </ul>
            </div>
        </div>
    </div>
</div>

        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
        Show:
        <label for="api-show-inherited" class="checkbox">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected" class="checkbox">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private" class="checkbox">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated" class="checkbox">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </form>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
    <h1>lib/api/graph.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
var Arango = require(&#x27;../arango&#x27;),
    url = require(&#x27;../url&#x27;),
    utils = require(&#x27;../utils&#x27;);

var compareOperators = [&quot;==&quot;,&quot;!=&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;&gt;=&quot;,&quot;&lt;=&quot;];

function propertyCompare (compare) {
    if (!compare) return(&quot;==&quot;);

    if(typeof compare !== &#x27;string&#x27;)
	throw new Error(&quot;not a string&quot;);
    
    if(compareOperators.indexOf(compare) &lt; 0)
	throw new Error(&quot;unknown operator &quot; + compare);
    
    return compare;
}

function filterDirection(filter, options) {
    switch (filter.direction) {
    case &quot;in&quot;:
	options.direction = &quot;inbound&quot;;
	break;
    case &quot;out&quot;:
	options.direction = &quot;outbound&quot;;
	break;
    case &quot;any&quot;:
	options.direction = &quot;any&quot;;
	break;
    default:
    }
}

function filterStatement(filter, statement) {
    if (!filter) {
	return &quot; FILTER &quot; + statement;
    }

    if(typeof filter !== &#x27;string&#x27;)
	throw new Error(&quot;not a string&quot;);
    
    filter+= &quot; &amp;&amp; &quot; + statement;
    
    return filter;
}

/* fills a filter (throws exception) */
function propertyFilter (bindVars, filter, num, property, collname) {
    var statement;
    
    if (property.key === undefined) {
	throw new Error(&quot;undefined property key&quot;);
    }
    
    if (property.compare === &quot;HAS&quot;) {
	bindVars[&quot;key&quot; + num] = property.key;
	statement = &quot;HAS(&quot; + collname + &quot;, @key&quot; + num + &quot;) &quot;;
    } else if (property.compare === &quot;HAS_NOT&quot;) {
	bindVars[&quot;key&quot; + num.toString()] = property.key;
	statement = &quot;!HAS(&quot; + collname + &quot;, @key&quot; + num + &quot;) &quot;;
    } else if (property.value !== undefined) {
	bindVars[&quot;key&quot; + num.toString()] = property.key;
	bindVars[&quot;value&quot; + num.toString()] = property.value;
	statement = collname + &quot;[@key&quot; + num + &quot;] &quot;;
	statement+= propertyCompare(property.compare) + &quot; @value&quot; + num;
    } else throw new Error(&quot;unknown property filter&quot;);
    
    return filterStatement(filter,statement);
}

/* fills a properties filter */
function filterProperties (data, properties, collname) {
    var filter;

    if (Array.isArray(properties)) {
	properties.forEach(function(p,i){
	    filter = propertyFilter(data, filter, i, p, collname);
	});
    }
    else if (typeof properties === &#x27;object&#x27;) {
	filter = propertyFilter(data, filter, 0, properties, collname);
    }
    
    return filter;
}

/* fills a labels filter */
function filterLabels (bindVars, filter, labels, collname) {

    if (!Array.isArray(labels))
	throw new Error(&quot;labels not an array&quot;);
    
    if (!labels.length)
	throw new Error(&quot;no labels&quot;);
    
    bindVars.labels = labels;
    
    return filterStatement(filter, collname + &#x27;[&quot;$label&quot;] IN @labels&#x27;);
}

function createFilterQuery(bindVars, filter, collname) {
    var filterQuery = &quot;&quot;;
    
    if (filter.properties) {
	filterQuery+= filterProperties(bindVars, filter.properties, collname);
    }
    
    if (filter.labels) {
	filterQuery+= filterLabels(bindVars, filter.labels, collname);
    }
    
    return filterQuery;
}

function optionsToUrl(o, options, useKeep) {

    options = options || {};
    
    if (o._waitForSync &amp;&amp; typeof options.waitForSync !== &quot;boolean&quot;) {
	options.waitForSync = o._waitForSync;
    }
    if (useKeep &amp;&amp; !o._keepNull &amp;&amp; options.keepNull === undefined) {
	options.keepNull = o._keepNull;
    }

    return url.options(options);
}

/**
 * The api module to perform graph related operations on ArangoDB.
 *
 * The underlying collections of the graph are still accessible using the standard methods for collections. 
 * However the graph module adds an additional layer on top of these collections giving you the following guarantees:
 *
 * - All modifications are executed transactional
 * - If you delete a vertex all edges will be deleted, you will never have loose ends
 * - If you insert an edge it is checked if the edge matches the definition, your edge collections will only contain valid edges
 * These guarantees are lost if you access the collections in any other way than the graph module or AQL.
 *
 * @class graph
 * @module arango
 * @submodule graph
 **/
function GraphAPI(db) {
    var path = &quot;/_api/gharial&quot;,
	graphObject = {

	    /**
	     * creates a Graph.
	     *
	     * @param {String} graph - the name of the graph
	     * @param {String} edgeDefinitions - (optional) the definitions for edges. Compatibility: the name of the vertex collection.
	     * @param {String} vertexCollections - (optional) list of additional vertex collections Compatibility: the name of the edge collection
	     * @param {Boolean} waitForSync - if true wait until document has been synced to disk.
	     * @method create
	     * @return{Promise}
	     */
	    &quot;create&quot;: function (graph, edgeDefinitions, vertexCollections, waitForSync) {
		if(typeof graph !== &#x27;string&#x27;)
		    throw new Error(&quot;graph name is not a string&quot;);

		var data = {
		    name: graph
		};

		var options = {};

		// Decide if it is old format
		// edgeDefinitions was vertex collection
		// vertexCollections was edge collection
		if (edgeDefinitions &amp;&amp; vertexCollections
		    &amp;&amp; typeof edgeDefinitions === &quot;string&quot;
		    &amp;&amp; typeof vertexCollections === &quot;string&quot;) {

		    data.edgeDefinitions = [{
			collection: vertexCollections,
			from: [edgeDefinitions],
			to: [edgeDefinitions]
		    }];
		    
		    if(waitForSync !== undefined)
			options.waitForSync = !!waitForSync;
		    
		} else {

		    if(typeof edgeDefinitions === &#x27;object&#x27;){
			data.edgeDefinition = edgeDefinitions;
			
			if(typeof vertexCollections === &#x27;object&#x27;)
			    data.orphanCollections = vertexCollections;
			else if(typeof vertexCollections === &#x27;boolean&#x27;)
			    waitForSync = vertexCollections;
		    }
		    else if(typeof edgeDefinitions === &#x27;boolean&#x27;)
			waitForSync = edgeDefinitions;

		    if(waitForSync !== undefined)
			options.waitForSync = !!waitForSync;

		}

		return db.post(path + optionsToUrl(this, options), data);
	    },
	    /**
	     * retrieves a graph from the database
	     *
	     * @param {String} graph - the name of the graph
	     * @method get
	     * @return{Promise}
	     */
	    &quot;get&quot;: function (graph) {
		return db.get(path + &#x27;/&#x27; + graph);
	    },
	    /**
	     * retrieves a list of graphs from the database
	     *
	     * @method list
	     * @return{Promise}
	     */
	    &quot;list&quot;: function () {
		return db.get(path);
	    },
	    /**
	     * Deletes a graph
	     *
	     * @param {String} graph - the name of the graph
	     * @param {Boolean} [waitForSync=false] - wait until document has been sync to disk.
	     * @method delete
	     * @return{Promise}
	     */
	    &quot;delete&quot;: function (graph, waitForSync) {

		var options = {};
		
		if (typeof waitForSync === &quot;boolean&quot;) {
		    options.waitForSync = waitForSync;
		}
		
		return db.delete(path + &#x27;/&#x27; + graph + optionsToUrl(this, options));
	    },
	    &quot;vertexCollections&quot;: {

		/**
		 * Lists all vertex collections
		 *
		 * @param {String} graph - the name of the graph
		 * @method list
		 * @return{Promise}
		 */
		&quot;list&quot;: function(graph) {
		    return db.get(path + &#x27;/&#x27; + graph + &quot;/vertex&quot;);
		},

		/**
		 * Add another vertex collection
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} collectionName - the name of the collection.
		 * @method list
		 * @return{Promise}
		 */
		&quot;add&quot;: function(graph, collectionName) {
		    var data = {
			collection: collectionName
		    };
		    
		    return db.post(path + &#x27;/&#x27; + graph + &quot;/vertex&quot;, data);
		},

		/**
		 * Remove a vertex collection from the graph
		 * The collection may not be used in an edge definition of this graph.
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} collectionName - the name of the collection.
		 * @method list
		 * @return{Promise}
		 */
		&quot;delete&quot;: function(graph, collectionName) {
		    return db.delete(path + &#x27;/&#x27; + graph + &quot;/vertex/&quot; + collectionName);
		}
	    },

	    &quot;edgeCollections&quot;: {

		/**
		 * Lists all edge collections
		 *
		 * @param {String} graph - the name of the graph
		 * @method list
		 * @return{Promise}
		 */
		&quot;list&quot;: function(graph) {
		    return db.get(path + &#x27;/&#x27; + graph + &quot;/edge&quot;);
		},

		/**
		 * Add another edge definition
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} collectionName - the name of the collection.
		 * @method list
		 * @return{Promise}
		 */
		&quot;add&quot;: function(graph, collectionName, from, to) {
		    if (typeof from === &quot;string&quot;) {
			from = [from];
		    }
		    if (typeof to === &quot;string&quot;) {
			to = [to];
		    }
		    
		    var data = {
			collection: collectionName,
			to: to,
			from: from
		    };
		    
		    return db.post(path + &#x27;/&#x27; + graph + &quot;/edge&quot;, data);
		},

		&quot;replace&quot;: function(graph, collectionName, from, to) {
		    if (typeof from === &quot;string&quot;) {
			from = [from];
		    }
		    if (typeof to === &quot;string&quot;) {
			to = [to];
		    }
		    var data = {
			collection: collectionName,
			to: to,
			from: from
		    };
		    return db.put(path + &#x27;/&#x27; + graph + &quot;/edge/&quot; + collectionName, data);
		},

		/**
		 * Remove a edge collection from the graph
		 * All vertex collections will still be known to the graph and
		 * have to be removed seperately.
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} collectionName - the name of the collection.
		 * @method list
		 * @return{Promise}
		 */
		&quot;delete&quot;: function(graph, collectionName) {
		    return db.delete(path + &#x27;/&#x27; + graph + &quot;/edge/&quot; + collectionName);
		}
	    },
	    &quot;vertex&quot;: {

		/**
		 * creates a Vertex within a Graph
		 *
		 * @param {String} graph - the name of the graph
		 * @param vertexData - the vertex object as JSON. It is possible to set the vertex key by providing the _key attribute.
		 * @param {String} collection - vertex collection name
		 * @param {Boolean} [waitForSync=false] - wait until document has been sync to disk.
		 * @method vertex.create
		 * @return{Promise}
		 */
		&quot;create&quot;: function (graph, vertexData, collection, waitForSync) {
		    var options = {}, collections, urlOptions, result;
		    
		    if(typeof collection !== &#x27;string&#x27;){
			waitForSync = collection;
			collection = undefined;
		    }
		    
		    if (waitForSync !== undefined) {
			options.waitForSync = !!waitForSync;
		    }

		    urlOptions = optionsToUrl(this, options);


		    if(!collection) {
			// if the graph contains a single vertexcollection we can use that
			result = graphObject.vertexCollections.list(graph)
			    .then(function(ret){
				if (ret.collections.length !== 1) {
				    throw &quot;The vertex collection is not unambigiously defined. Please give it explicitly.&quot;;
				}
				return db.post(path + &#x27;/&#x27; + graph + &#x27;/vertex/&#x27; + ret.collections[0] + urlOptions, vertexData);
			    });
		    } else {
			result = db.post(path + &#x27;/&#x27; + graph + &#x27;/vertex/&#x27; + collection + urlOptions, vertexData);
		    }
		    
		    return result;
		},

		/**
		 * retrieves a vertex from a graph
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the vertex-handle
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @method vertex.get
		 * @return{Promise}
		 */
		&quot;get&quot;: function (graph, id, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);
		    }
		    
		    return db.get(path + &#x27;/&#x27; + graph + &#x27;/vertex/&#x27; + id + optionsToUrl(this, options), headers);
		},
		/**
		 * replaces a vertex with the data given in data.
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the vertex-handle
		 * @param {Object} data - the data of the vertex as JSON object
		 * @param {Object} [options] - an object with the following optional parameters:
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @param {Boolean} [options.forceUpdate] - If set an update is performed even when the given revision
		 * does not match.
		 * @param {Boolean} [options.waitForSync=false] -  Wait until document has been synced to disk.
		 * @method vertex.put
		 * @return{Promise}
		 */
		&quot;put&quot;: function (graph, id, data, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);

			if (options.forceUpdate !== undefined) {
			    options.policy = (options.forceUpdate === true) ? &quot;last&quot; : &quot;error&quot;;
			    delete options.forceUpdate;
			}
		    }
		    
		    return db.put(path + &#x27;/&#x27; + graph + &#x27;/vertex/&#x27; + id + optionsToUrl(this, options), data, headers);
		},
		/**
		 * patches a vertex with the data given in data
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the vertex-handle
		 * @param {Object} data - the data of the vertex as JSON object
		 * @param {Object} [options] - an object with the following optional parameters:
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @param {Boolean} [options.forceUpdate] - If set an update is performed even when the given revision
		 * does not match.
		 * @param {Boolean} [options.waitForSync=false] -  Wait until document has been synced to disk.
		 * @param {Boolean} [options.keepNull=true] -  if set to false a patch request will delete every null value
		 * @method vertex.patch
		 * @return{Promise}
		 */
		&quot;patch&quot;: function (graph, id, data, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);

			if (options.forceUpdate !== undefined) {
			    options.policy = (options.forceUpdate === true) ? &quot;last&quot; : &quot;error&quot;;
			    delete options.forceUpdate;
			}
		    }
		    
		    return db.patch(path + &#x27;/&#x27; + graph + &#x27;/vertex/&#x27; + id + optionsToUrl(this, options, true), data, headers);
		},
		/**
		 * Deletes a vertex
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the vertex-handle
		 * @param {Object} [options] - an object with the following optional parameters:
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @param {Number} [options.waitForSync] -  Boolean, wait until document has been synced to disk.
		 * @param {Boolean} [options.forceUpdate] - If set an update is performed even when the given revision
		 * does not match.
		 * @method vertex.delete
		 * @return{Promise}
		 */
		&quot;delete&quot;: function (graph, id, options) {
		    var headers, urlOptions;

		    if (options) {
			headers = url.ifMatch(id, options);
		    }

		    urlOptions = optionsToUrl(this,options);

		    return db.delete(path + &#x27;/&#x27; + graph + &#x27;/vertex/&#x27; + id + urlOptions, headers);
		}
	    },

	    &quot;edge&quot;: {
		/**
		 * creates an edge within a Graph
		 *
		 * @param {String} graph - the name of the graph
		 * @param edgeData  - the vertex object as JSON. It is possible to set the vertex key by providing the _key attribute.
		 * @param {String} from      - the start vertex of this edge
		 * @param {String} to        - the end vertex of this edge
		 * @param {String} label     - the edges label
		 * @param {String} collection - the edge collection
		 * @param {Boolean} [waitForSync=false] - wait until document has been sync to disk.
		 * @method edge.create
		 * @return{Promise}
		 */
		&quot;create&quot;: function (graph, edgeData, from, to, label, collection, waitForSync) {
		    var options = {}, urlOptions, result;

		    var data = edgeData || {};
		    
		    if (to) data._to = to;
		    if (from) data._from = from;
		    if (label) data.$label = label;
		    
		    if(typeof collection !== &#x27;string&#x27;){
			waitForSync = collection;
			collection = undefined;
		    }
		    
		    if (waitForSync !== undefined) {
			options.waitForSync = !!waitForSync;
		    }

		    urlOptions = optionsToUrl(this, options);

		    if(!collection) {
			// if the graph contains a single edge collection we can use that
			result = graphObject.edgeCollections.list(graph)
			    .then(function(ret){
				if (ret.collections.length !== 1) {
				    throw &quot;The edge collection is not unambigiously defined. Please give it explicitly.&quot;;
				}
				return db.post(path + &#x27;/&#x27; + graph + &#x27;/edge/&#x27; + ret.collections[0] + urlOptions, data);
			    });
		    } else {
			result = db.post(path + &#x27;/&#x27; + graph + &#x27;/edge/&#x27; + collection + urlOptions, data);
		    }
		    
		    return result;
		},
		/**
		 * retrieves an edge  from a graph
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the edge-handle
		 * @param {Object} [options] - an object with the following optional parameters:
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @method edge.get
		 * @return{Promise}
		 */
		&quot;get&quot;: function (graph, id, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);
		    }
		    
		    return db.get(path + &#x27;/&#x27; + graph + &#x27;/edge/&#x27; + id + optionsToUrl(this, options), headers);
		},
		/**
		 * replaces an edge with the data given in data.
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the vertex-handle
		 * @param {Object} data - the data of the edge as JSON object
		 * @param {Object} [options] - an object with the following optional parameters:
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @param {Boolean} [options.forceUpdate] - If set an update is performed even when the given revision
		 * does not match.
		 * @param {Boolean} [options.waitForSync=false] -  Wait until document has been synced to disk.
		 * @method edge.put
		 * @return{Promise}
		 */
		&quot;put&quot;: function (graph, id, data, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);

			if (options.forceUpdate !== undefined) {
			    options.policy = (options.forceUpdate === true) ? &quot;last&quot; : &quot;error&quot;;
			    delete options.forceUpdate;
			}
		    }

		    return db.put(path + &#x27;/&#x27; + graph + &#x27;/edge/&#x27; + id + optionsToUrl(this, options), data, headers);
		},
		/**
		 * patches an edge with the data given in data
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the edge-handle
		 * @param {Object} data - the data of the edge as JSON object
		 * @param {Object} [options] - an object with the following optional parameters:
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @param {Boolean} [options.forceUpdate] - If set an update is performed even when the given revision
		 * does not match.
		 * @param {Boolean} [options.waitForSync=false] -  Wait until document has been synced to disk.
		 * @param {Boolean} [options.keepNull=true] -  if set to false a patch request will delete every null value
		 * @method edge.patch
		 * @return{Promise}
		 */
		&quot;patch&quot;: function (graph, id, data, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);

			if (options.forceUpdate !== undefined) {
			    options.policy = (options.forceUpdate === true) ? &quot;last&quot; : &quot;error&quot;;
			    delete options.forceUpdate;
			}
		    }
		    
		    return db.patch(path + &#x27;/&#x27; + graph + &#x27;/edge/&#x27; + id + optionsToUrl(this, options, true), data, headers);
		},
		/**
		 * Deletes an edge
		 *
		 * @param {String} graph - the name of the graph
		 * @param {String} id        - the edge-handle
		 * @param {Boolean} [options.match] - defining if the given revision should match the found document or not.
		 * @param {Number} [options.rev] -  The revision, used by the &quot;match&quot; attribute.
		 * @param {Boolean} [options.forceUpdate] - If set an update is performed even when the given revision
		 * does not match.
		 * @param {Boolean} [options.waitForSync=false] -  Wait until document has been synced to disk.
		 * @method edge.delete
		 * @return{Promise}
		 */
		&quot;delete&quot;: function (graph, id, options) {
		    var headers;

		    if (options) {
			headers = url.ifMatch(id, options);
		    }

		    return db.delete(path + &#x27;/&#x27; + graph + &#x27;/edge/&#x27; + id + optionsToUrl(this, options), headers);
		}
	    },
	    /**
	     * returns all neighbouring vertices of the given vertex .
	     *
	     * @param {String} graph - the name of the graph
	     * @param {String} vertex - the vertex
	     * @param {Object} [options]   - the following optional parameters are allowed:
	     * @param {Number} [options.batchSize] - the batch size of the returned cursor.
	     * @param {Number} [options.limit] -  limit the result size.
	     * @param {Boolean} [options.count=false]  -   return the total number of results.
	     * @param {Object} [options.filter] -   a optional filter, The attributes of filter:
	     * @param {String} [options.direction=any]     filter for inbound (value &quot;in&quot;) or outbound (value &quot;out&quot;)
	     * neighbors.
	     * @param {List} [options.filter.labels]  -   filter by an array of edge labels (empty array means no
	     * restriction)
	     * @param {Object} [options.filter.properties]  -   filter neighbors by an array of edge properties, The
	     * attributes of a property filter:
	     * @param {String} [options.filter.key] -   filter the result vertices by a key value pair
	     * @param {String} [options.filter.value]   -   the value of the key
	     * @param {String} [options.filter.compare] -   a compare operator
	     * @method getNeighbourVertices
	     * @return{Promise}
	     */

	    &quot;getNeighbourVertices&quot;: function (graph, vertex, options) {
		var bindVars = {graphName:graph,example:vertex,options:{}},
		    queryData = {bindVars:bindVars},
		    filter;
		
		options = options || {};
		filter = options.filter || {};
		
		filterDirection(filter, bindVars.options);
		
		queryData.query = &quot;FOR u IN GRAPH_NEIGHBORS(@graphName,@example,@options) &quot;;
		queryData.query += createFilterQuery(bindVars, filter, &quot;u.path.edges[0]&quot;);

		if (options.limit) {
		    queryData.query += &quot; LIMIT @limit&quot;;
		    bindVars.limit = options.limit;
		}
		
		queryData.query += &quot; RETURN u.vertex&quot;;

		if(options.count) queryData.count = options.count;
		if(options.batchSize) queryData.batchSize = options.batchSize;
		
		return db.cursor.create(queryData);
	    },
	    /**
	     * returns all neighbouring edges of the given vertex .
	     *
	     * @param {String} graph - the name of the graph
	     * @param {String} vertex - the vertex
	     * @param {Object} [options]   - the following optional parameters are allowed:
	     * @param {Number} [options.batchSize] - the batch size of the returned cursor.
	     * @param {Number} [options.limit] -  limit the result size.
	     * @param {Boolean} [options.count=false]  -   return the total number of results.
	     * @param {Object} [options.filter] -   a optional filter, The attributes of filter:
	     * @param {String} [options.direction=any]     filter for inbound (value &quot;in&quot;) or outbound (value &quot;out&quot;)
	     * neighbors.
	     * @param {List} [options.filter.labels]  -   filter by an array of edge labels (empty array means no
	     * restriction)
	     * @param {Object} [options.filter.properties]  -   filter neighbors by an array of edge properties, The
	     * attributes of a property filter:
	     * @param {String} [options.filter.key] -   filter the result vertices by a key value pair
	     * @param {String} [options.filter.value]   -   the value of the key
	     * @param {String} [options.filter.compare] -   a compare operator
	     * @method getEdgesForVertex
	     * @return{Promise}
	     */
	    &quot;getEdgesForVertex&quot;: function (graph, vertex, options) {
		var bindVars = {graphName:graph,example:vertex,options:{}},
		    queryData = {bindVars:bindVars},
		    filter;
		
		options = options || {};
		filter = options.filter || {};
		
		filterDirection(filter, bindVars.options);
		
		queryData.query = &quot;FOR e IN GRAPH_EDGES(@graphName,@example,@options) &quot;;
		queryData.query += createFilterQuery(bindVars, filter, &quot;e&quot;);
		queryData.query += &quot; RETURN e&quot;;
		
		if(options.count) queryData.count = options.count;
		if(options.batchSize) queryData.batchSize = options.batchSize;
		
		return db.cursor.create(queryData);
	    },
	    /**
	     * returns all vertices of a graph.
	     *
	     * @param {String} graph - the name of the graph.
	     * @param {Object} [options]   - the following optional parameters are allowed:
	     * @param {Number} [options.batchSize] - the batch size of the returned cursor.
	     * @param {Number} [options.limit] -  limit the result size.
	     * @param {Boolean} [options.count=false]  -   return the total number of results.
	     * @param {Object} [options.filter] -   a optional filter, The attributes of filter:
	     * @param {Object} [options.filter.properties]  -   filter neighbors by an array of edge properties, The
	     * attributes of a property filter:
	     * @param {String} [options.filter.key] -   filter the result vertices by a key value pair
	     * @param {String} [options.filter.value]   -   the value of the key
	     * @param {String} [options.filter.compare] -   a compare operator
	     * @method vertices
	     * @return{Promise}
	     */

	    &quot;vertices&quot;: function (graph, options) {
		var bindVars = {graphName:graph,options:{}},
		    queryData = {bindVars:bindVars},
		    filter;
		
		options = options || {};
		filter = options.filter || {};
		
		filterDirection(filter, bindVars.options);
		
		queryData.query = &quot;FOR v IN GRAPH_VERTICES(@graphName,{},@options) &quot;;
		queryData.query += createFilterQuery(bindVars, filter, &quot;v&quot;);
		queryData.query += &quot; RETURN v&quot;;
		
		queryData.count = options.count;
		queryData.batchSize = options.batchSize;
		
		return db.cursor.create(queryData);
	    },
	    /**
	     * returns all edges of a graph.
	     *
	     * @param {String} graph - the name of the graph.
	     * @param {Object} [options]   - the following optional parameters are allowed:
	     * @param {Number} [options.batchSize] - the batch size of the returned cursor.
	     * @param {Number} [options.limit] -  limit the result size.
	     * @param {Boolean} [options.count=false]  -   return the total number of results.
	     * @param {Object} [options.filter] -   a optional filter, The attributes of filter:
	     * @param {List} [options.filter.labels]  -   filter by an array of edge labels (empty array means no
	     * restriction)
	     * @param {Object} [options.filter.properties]  -   filter neighbors by an array of edge properties,
	     * The attributes of a property filter:
	     * @param {String} [options.filter.key] -   filter the result vertices by a key value pair
	     * @param {String} [options.filter.value]   -   the value of the key
	     * @param {String} [options.filter.compare] -   a compare operator
	     * @method edges
	     * @return{Promise}
	     */
	    &quot;edges&quot;: function (graph, options) {
		var bindVars = {graphName:graph,options:{}},
		    queryData = {bindVars:bindVars},
		    filter;
		
		options = options || {};
		filter = options.filter || {};
		
		filter.direction = filter.direction || &quot;out&quot;; 

		filterDirection(filter, bindVars.options);
		
		queryData.query = &quot;FOR e IN GRAPH_EDGES(@graphName,{},@options) &quot;;
		queryData.query += createFilterQuery(bindVars, filter, &quot;e&quot;);
		queryData.query += &quot; RETURN e&quot;;
		
		queryData.count = options.count;
		queryData.batchSize = options.batchSize;
		
		return db.cursor.create(queryData);
	    },
	    /**
	     * Sets the keepNull value for all further requests in the graph module.
	     *
	     * @param {Boolean} val
	     * @method keepNull
	     * @return {Object}    -   The modified instance of the graph module.
	     */
	    &quot;keepNull&quot;: function (val) {
		this._keepNull = !!val;
		this.vertex._keepNull = !!val;
		this.edge._keepNull = !!val;

		return this;
	    },

	    /**
	     * Sets the waitForSync value for all further requests in the graph module.
	     *
	     * @param {Boolean} val
	     * @method waitForSync
	     * @return {Object}    -   The modified instance of the graph module.
	     */
	    &quot;waitForSync&quot;: function (val) {
		this._waitForSync = !!val;
		this.vertex._waitForSync = !!val;
		this.edge._waitForSync = !!val;

		return this;
	    }
	};
    
    return graphObject;
}

module.exports = Arango.api(&#x27;graph&#x27;, GraphAPI);

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
